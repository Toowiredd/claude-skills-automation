# v2.0.1 Critical Fixes

**Status**: In Progress
**Priority**: HIGH - Must release before wider distribution

These fixes address the 6 critical issues identified in edge case analysis.

---

## ‚úÖ Fix #1: Empty index.json on First Install (COMPLETE)

**Issue**: New users' first session fails because index.json doesn't exist

**Status**: ‚úÖ **FIXED** in install.sh

**Change**: Added default index.json creation to install script

```bash
# In scripts/install.sh (lines 160-188)
# Creates default index.json with empty state if file doesn't exist
```

**Verification**:
```bash
# Test
rm -rf ~/.claude-memories
bash scripts/install.sh
cat ~/.claude-memories/index.json  # Should show default structure
```

---

## üîß Fix #2: Hook Error Handling (NEEDED)

**Issue**: Single hook failure breaks entire automation system

**Status**: ‚ö†Ô∏è **NEEDS IMPLEMENTATION**

**Required Changes**:

### session-start.sh
```bash
#!/usr/bin/env bash
# Add at top
set +e  # Don't exit on first error

# Wrap critical operations
read_index() {
  local index_file="$HOME/.claude-memories/index.json"

  if [ ! -f "$index_file" ]; then
    echo "‚ö†Ô∏è Memory index not found, starting with empty state" >&2
    echo '{"memories":[]}'
    return 0
  fi

  local content
  content=$(cat "$index_file" 2>/dev/null)

  if [ $? -ne 0 ]; then
    echo "‚ö†Ô∏è Could not read memory index" >&2
    echo '{"memories":[]}'
    return 0
  fi

  # Validate JSON
  if ! echo "$content" | jq empty 2>/dev/null; then
    echo "‚ö†Ô∏è Corrupted memory index detected, backing up..." >&2
    cp "$index_file" "$index_file.corrupted.$(date +%s)" 2>/dev/null
    echo '{"memories":[]}'
    return 0
  fi

  echo "$content"
}

# Use the function
INDEX_DATA=$(read_index)
MEMORIES=$(echo "$INDEX_DATA" | jq '.memories' 2>/dev/null || echo '[]')

# Continue with injection...
```

### session-end.sh
```bash
#!/usr/bin/env bash
set +e  # Don't exit on errors

# Wrap save operations
save_session_state() {
  local session_dir="$HOME/.claude-sessions/projects"
  mkdir -p "$session_dir" 2>/dev/null || return 1

  # Try to save, but don't fail if it doesn't work
  echo "$SESSION_DATA" > "$session_dir/current.json" 2>/dev/null || {
    echo "‚ö†Ô∏è Could not save session state" >&2
    return 1
  }

  return 0
}

# Call with error handling
if ! save_session_state; then
  echo "‚ö†Ô∏è Session save failed, but continuing..." >&2
fi
```

### stop-extract-memories.sh
```bash
#!/usr/bin/env bash
set +e

# Wrap extraction logic
extract_memories() {
  local input="$1"

  # Try to parse JSON
  if ! echo "$input" | jq empty 2>/dev/null; then
    echo "‚ö†Ô∏è Invalid input JSON, skipping extraction" >&2
    return 1
  fi

  # Extract with fallback
  local messages
  messages=$(echo "$input" | jq -r '.messages[]?.content' 2>/dev/null)

  if [ -z "$messages" ]; then
    echo "‚ö†Ô∏è No messages to extract from" >&2
    return 1
  fi

  # Continue extraction...
}

# Call with error handling
if ! extract_memories "$INPUT_DATA"; then
  echo "‚ö†Ô∏è Memory extraction failed, but session continues" >&2
fi
```

**Verification**:
```bash
# Test 1: Corrupted JSON
echo "invalid json" > ~/.claude-memories/index.json
# Start session ‚Üí should recover gracefully

# Test 2: Missing file
rm ~/.claude-memories/index.json
# Start session ‚Üí should create default

# Test 3: Permission denied
chmod 000 ~/.claude-memories/
# Hooks should report error but not crash
chmod 755 ~/.claude-memories/
```

---

## üéØ Fix #3: Project Context Filtering (NEEDED)

**Issue**: Decisions from all projects mixed together, causing confusion

**Status**: ‚ö†Ô∏è **NEEDS IMPLEMENTATION**

**Required Changes**:

### Update Memory Schema

**Current** (index.json):
```json
{
  "id": "uuid",
  "type": "DECISION",
  "content": "Using React",
  "created": "2025-10-17"
}
```

**New** (add project tracking):
```json
{
  "id": "uuid",
  "type": "DECISION",
  "content": "Using React",
  "project": "abc123def",  // NEW: project hash
  "cwd": "/home/user/ProjectA",  // NEW: working directory
  "git_repo": "/home/user/ProjectA",  // NEW: git root (if available)
  "created": "2025-10-17"
}
```

### Update stop-extract-memories.sh

```bash
# Detect current project
detect_project() {
  local project_id

  # Try git repository root first
  if git rev-parse --show-toplevel &>/dev/null; then
    project_id=$(git rev-parse --show-toplevel)
  else
    # Fall back to current working directory
    project_id="$PWD"
  fi

  # Hash it for privacy
  echo "$project_id" | md5sum | cut -d' ' -f1
}

# When saving memory
PROJECT_ID=$(detect_project)
PROJECT_PATH=$(git rev-parse --show-toplevel 2>/dev/null || echo "$PWD")

# Add to memory JSON
jq --arg project "$PROJECT_ID" \
   --arg cwd "$PWD" \
   --arg git_repo "$PROJECT_PATH" \
   '.project = $project | .cwd = $cwd | .git_repo = $git_repo' \
   memory.json
```

### Update session-start.sh

```bash
# Filter memories by current project
detect_project() {
  local project_id

  if git rev-parse --show-toplevel &>/dev/null; then
    project_id=$(git rev-parse --show-toplevel)
  else
    project_id="$PWD"
  fi

  echo "$project_id" | md5sum | cut -d' ' -f1
}

CURRENT_PROJECT=$(detect_project)

# Get memories for current project only
RECENT_DECISIONS=$(jq --arg project "$CURRENT_PROJECT" '
  .memories[] |
  select(.type == "DECISION") |
  select(.project == $project or .project == null) |  # Include old memories without project
  sort_by(.created) |
  reverse |
  limit(10; .) |
  .content
' ~/.claude-memories/index.json)
```

### Migration Script

For existing users with old memories:

```bash
#!/usr/bin/env bash
# scripts/migrate-to-v2.0.1.sh

echo "üîÑ Migrating memories to v2.0.1 schema..."

# Backup current index
cp ~/.claude-memories/index.json ~/.claude-memories/index.json.pre-v2.0.1

# Add project=null to old memories (will show in all projects)
jq '.memories[] |= . + {project: null, cwd: null, git_repo: null}' \
  ~/.claude-memories/index.json > ~/.claude-memories/index.json.new

mv ~/.claude-memories/index.json.new ~/.claude-memories/index.json

echo "‚úÖ Migration complete"
echo "Old memories will appear in all projects (project=null)"
echo "New memories will be project-specific"
```

**Verification**:
```bash
# Test
cd /tmp/ProjectA
# Work, make decision: "Using React"

cd /tmp/ProjectB
# Work, make decision: "Using Vue"

cd /tmp/ProjectA
# Start session ‚Üí should only see "React" decision

cd /tmp/ProjectB
# Start session ‚Üí should only see "Vue" decision
```

---

## üìè Fix #4: Token Limit on SessionStart (NEEDED)

**Issue**: Power users with 100+ decisions exceed context window

**Status**: ‚ö†Ô∏è **NEEDS IMPLEMENTATION**

**Required Changes**:

### Add Configuration File

```bash
# ~/.config/claude-code/automation.conf
MAX_INJECTED_DECISIONS=10
MAX_INJECTED_BLOCKERS=5
MAX_INJECTED_CONTEXT=3
TOKEN_LIMIT_ESTIMATE=2000

# Optional: User can adjust based on their needs
```

### Update session-start.sh

```bash
# Load configuration
load_config() {
  local config_file="$HOME/.config/claude-code/automation.conf"

  # Defaults
  MAX_DECISIONS=10
  MAX_BLOCKERS=5
  MAX_CONTEXT=3

  if [ -f "$config_file" ]; then
    source "$config_file"
    MAX_DECISIONS=${MAX_INJECTED_DECISIONS:-10}
    MAX_BLOCKERS=${MAX_INJECTED_BLOCKERS:-5}
    MAX_CONTEXT=${MAX_INJECTED_CONTEXT:-3}
  fi
}

load_config

# Limit decisions to most recent N
RECENT_DECISIONS=$(jq --arg project "$CURRENT_PROJECT" --argjson limit "$MAX_DECISIONS" '
  .memories[] |
  select(.type == "DECISION") |
  select(.project == $project or .project == null) |
  sort_by(.created) |
  reverse |
  limit($limit; .) |
  .content
' ~/.claude-memories/index.json)

# Limit blockers to active only
ACTIVE_BLOCKERS=$(jq --argjson limit "$MAX_BLOCKERS" '
  .memories[] |
  select(.type == "BLOCKER") |
  select(.resolved != true) |
  sort_by(.created) |
  reverse |
  limit($limit; .) |
  .content
' ~/.claude-memories/index.json)

# Add token counter (rough estimate)
estimate_tokens() {
  local text="$1"
  # Rough estimate: 1 token ‚âà 4 characters
  echo "$text" | wc -c | awk '{print int($1/4)}'
}

TOTAL_TOKENS=$(echo "$CONTEXT_TO_INJECT" | estimate_tokens)

if [ "$TOTAL_TOKENS" -gt 2000 ]; then
  echo "‚ö†Ô∏è Context exceeds token limit ($TOTAL_TOKENS > 2000), truncating..." >&2
  # Further reduce limits
  MAX_DECISIONS=5
  MAX_BLOCKERS=3
  # Re-run injection with lower limits
fi
```

**Verification**:
```bash
# Test: Add 50 decisions
for i in {1..50}; do
  echo "Decision $i" >> ~/.claude-memories/decisions/decision-$i.md
done

# Update index.json to reflect 50 decisions

# Start session
# Check that only 10 most recent are injected
```

---

## üîç Fix #5: Duplicate Detection (NEEDED)

**Issue**: Same decision saved multiple times

**Status**: ‚ö†Ô∏è **NEEDS IMPLEMENTATION**

**Required Changes**:

### Update stop-extract-memories.sh

```bash
# Fuzzy match function
fuzzy_match() {
  local new_content="$1"
  local existing_content="$2"

  # Normalize both strings
  local normalized_new=$(echo "$new_content" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]//g')
  local normalized_existing=$(echo "$existing_content" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]//g')

  # Calculate similarity (simple approach: substring match)
  if echo "$normalized_existing" | grep -q "$normalized_new"; then
    return 0  # Match found
  fi

  if echo "$normalized_new" | grep -q "$normalized_existing"; then
    return 0  # Match found
  fi

  return 1  # No match
}

# Before saving new decision
check_duplicate() {
  local new_decision="$1"
  local type="$2"

  # Get existing memories of same type
  existing_memories=$(jq --arg type "$type" '
    .memories[] |
    select(.type == $type) |
    .content
  ' ~/.claude-memories/index.json)

  # Check each existing memory
  while IFS= read -r existing; do
    if fuzzy_match "$new_decision" "$existing"; then
      echo "DUPLICATE"
      return 0
    fi
  done <<< "$existing_memories"

  echo "NEW"
  return 1
}

# When extracting decision
EXTRACTED_DECISION="using PostgreSQL"

DUPLICATE_CHECK=$(check_duplicate "$EXTRACTED_DECISION" "DECISION")

if [ "$DUPLICATE_CHECK" = "DUPLICATE" ]; then
  echo "‚ö†Ô∏è Duplicate decision detected, updating timestamp instead" >&2

  # Update existing memory timestamp
  jq --arg content "$EXTRACTED_DECISION" '
    .memories |= map(
      if .content | contains($content) then
        . + {last_mentioned: "'$(date -Iseconds)'"}
      else
        .
      end
    )
  ' ~/.claude-memories/index.json > ~/.claude-memories/index.json.new

  mv ~/.claude-memories/index.json.new ~/.claude-memories/index.json
else
  # Save new decision
  save_new_decision "$EXTRACTED_DECISION"
fi
```

**Verification**:
```bash
# Test
# Say "using PostgreSQL" twice in same session
# Check that only one memory is saved, with updated timestamp
```

---

## üé® Fix #6: Skill Priority System (NEEDED)

**Issue**: Multiple skills trigger on same phrase (e.g., "create prototype")

**Status**: ‚ö†Ô∏è **NEEDS IMPLEMENTATION**

**Required Changes**:

### Update Skill Descriptions

**browser-app-creator/SKILL.md**:
```yaml
---
name: browser-app-creator
description: Creates complete single-file HTML/CSS/JS web apps with localStorage persistence, ADHD-optimized UI (60px+ buttons), dark mode, and offline functionality. Use when user says "create app", "build tool", "make dashboard", or requests any browser-based interface.
priority: HIGH
conflicts_with: [rapid-prototyper]
prefer_when:
  - User wants COMPLETE, POLISHED web app
  - User wants ADHD optimization (large buttons, auto-save)
  - User wants something that WORKS OFFLINE
  - User wants DOWNLOADABLE HTML file
---
```

**rapid-prototyper/SKILL.md**:
```yaml
---
name: rapid-prototyper
description: Creates minimal working prototypes for quick idea validation. Single-file when possible, includes test data, ready to demo immediately. Use when user says "prototype", "MVP", "proof of concept", "quick demo".
priority: MEDIUM
conflicts_with: [browser-app-creator]
prefer_when:
  - User wants to VALIDATE AN IDEA quickly
  - User needs PROOF OF CONCEPT
  - User wants MINIMAL implementation
  - User doesn't care about polish
---
```

**Decision Logic** (for Claude):
```
If user says "create a prototype":
  1. Check if conflicts exist
  2. If browser-app-creator AND rapid-prototyper match:
     a. Check context for hints:
        - "quick", "simple", "test" ‚Üí rapid-prototyper
        - "app", "tool", "tracker", "complete" ‚Üí browser-app-creator
     b. If still ambiguous ‚Üí Ask user
```

### Add Disambiguation Prompt

When conflict detected:
```
I can help with that using either:

1. **browser-app-creator** - Creates a complete, polished web app with ADHD optimization, auto-save, and offline support
2. **rapid-prototyper** - Creates a quick prototype to validate the idea (minimal, but functional)

Which would you prefer?
```

**Verification**:
```bash
# Test scenarios:
# "create a prototype" ‚Üí Should ask for clarification
# "create a complete app" ‚Üí Should use browser-app-creator
# "quick prototype to test" ‚Üí Should use rapid-prototyper
```

---

## üìã Implementation Checklist

### v2.0.1 Patch Release
- [x] Fix #1: Empty index.json ‚úÖ **COMPLETE**
- [ ] Fix #2: Hook error handling ‚ö†Ô∏è **IN PROGRESS**
- [ ] Fix #3: Project context filtering ‚ö†Ô∏è **IN PROGRESS**
- [ ] Fix #4: Token limit ‚ö†Ô∏è **PLANNED**
- [ ] Fix #5: Duplicate detection ‚ö†Ô∏è **PLANNED**
- [ ] Fix #6: Skill priorities ‚ö†Ô∏è **PLANNED**

### Testing Required
- [ ] Test fresh install (Fix #1)
- [ ] Test corrupted JSON recovery (Fix #2)
- [ ] Test multi-project isolation (Fix #3)
- [ ] Test with 50+ decisions (Fix #4)
- [ ] Test duplicate extraction (Fix #5)
- [ ] Test skill conflicts (Fix #6)

### Documentation Updates
- [ ] Update README with fixes
- [ ] Update CHANGELOG (v2.0.1)
- [ ] Add troubleshooting section
- [ ] Create migration guide

---

## üöÄ Release Plan

1. **Phase 1** (Immediate): Fix #1 ‚úÖ DONE
2. **Phase 2** (Today): Fixes #2, #3
3. **Phase 3** (Tomorrow): Fixes #4, #5, #6
4. **Phase 4** (Testing): Full system test
5. **Phase 5** (Release): Push v2.0.1

**Target**: v2.0.1 released within 48 hours

---

## üìä Impact Assessment

| Fix | Users Affected | Severity | Effort |
|-----|---------------|----------|--------|
| #1 Empty index | 100% (new users) | HIGH | 1 hour ‚úÖ |
| #2 Error handling | 10% (corrupted state) | CRITICAL | 4 hours |
| #3 Project filtering | 50% (multi-project) | HIGH | 6 hours |
| #4 Token limit | 5% (power users) | MEDIUM | 3 hours |
| #5 Duplicate detection | 80% (all users) | MEDIUM | 4 hours |
| #6 Skill priorities | 30% (ambiguous requests) | LOW | 3 hours |

**Total Effort**: ~21 hours of development

**Priority Order**: #1 (done) ‚Üí #2 ‚Üí #3 ‚Üí #4 ‚Üí #5 ‚Üí #6

---

**Status**: Fix #1 complete, remaining fixes in progress.
